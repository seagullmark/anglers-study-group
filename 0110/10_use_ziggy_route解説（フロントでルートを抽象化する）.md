# useZiggyRoute の解説（フロントでルートを抽象化する）

このファイルは、フロントエンド（Vue / Inertia）で

- Laravel のルート名を
- **安全かつ一貫した方法で使うためのラッパー**

です。

一見小さなファイルですが、 **設計的には非常に重要な役割**を持っています。

---

## 対象コード

```js
import { useRoute } from 'ziggy-js'
import { Ziggy } from '@/ziggy'

export const useZiggyRoute = () => useRoute(Ziggy)
```

---

## 1. 何をしているファイルか

このファイルは、

- `ziggy-js` が提供する `useRoute`
- Laravel 側で生成された `Ziggy` ルート定義

を組み合わせて、

> **フロントで **``** 関数を使えるようにする**

ためのものです。

---

## 2. なぜ直接 useRoute を使わないのか

フロント側で毎回、

```js
useRoute(Ziggy)
```

と書いても動きます。

それでもこのラッパーを作っている理由は、

- ルート定義の依存先を **1か所に閉じ込める**
- 将来、Ziggy の設定を変えたくなった時に 修正箇所をここだけにする

ためです。

---

## 3. フロントでの使われ方

```js
const route = useZiggyRoute()

route('login.store')
route('logout')
```

フロント側のコードは、

- URL の文字列
- `/login` や `/logout` といったパス

を **一切知らずに**、

> ルート名だけ

を使っています。

---

## 4. なぜ URL を名前で扱うのか

ここが、この仕組みの **一番の実利** です。

> **URL を名前で扱っていると、URL を変更してもフロント側を直さなくてよい**

たとえば、

- `/login` → `/auth/login`
- `/logout` → `/auth/logout`

のように URL 構造を変更しても、

- ルート名（`login.store`, `logout`）が同じであれば
- フロント側のコードは一切変更不要

変更は **Laravel の routes 定義だけ**で完結します。

---

## 5. 抽象化（設計）の観点

ここでも抽象化が行われています。

- フロントは URL 構造を知らない
- フロントはルーティング定義の場所を知らない

知っているのは、

> **この名前のルートが存在する**

という事実だけです。

---

## 5. 認証フローとの関係

この教材では、

- `login.store`
- `logout`

といったルート名を、

- Login 画面
- Index 画面

から呼び出しています。

フロント側は、

- そのルートが auth / guest どちらか
- 認証がどう実装されているか

を知りません。

> ルート名を呼ぶだけで、 正しい先に送られる

という状態が保たれています。

---

## 6. FileMaker を意識しない理由

このファイルでも、

- User が FileMaker にあるかどうか
- 認証処理の実装

は一切関係ありません。

ルーティングと URL の問題は、

> **認証やデータ保存とは独立した関心事**

として切り離されています。

---

## 7. FileMaker 開発への持ち帰り

この考え方は FileMaker にもそのまま使えます。

- スクリプト名だけを呼ぶ
- レイアウト名や内部構造を直接参照しない
- 呼び出し口を1か所にまとめる

という設計は、

> 「変更に強い FileMaker 実装」

につながります。

---

## 8. まとめ

- useZiggyRoute はフロント用の小さなラッパー
- ルート定義への依存を1か所に閉じ込める
- フロントでも「抽象化」が行われている

この小さなファイルも、

> **設計のヒントが詰まった実例**

です。
